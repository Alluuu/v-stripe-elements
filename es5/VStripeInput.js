"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

require("../src/VStripeInput.sass");

var _lib = require("vuetify/lib");

var _mixins = _interopRequireDefault(require("vuetify/lib/util/mixins"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var base = (0, _mixins["default"])(_lib.VTextField); // Extend `base` to define the VStripeInput component

var _default = base.extend({
  name: 'v-stripe-input',
  "extends": _lib.VTextField,
  inheritAttrs: false,
  props: {
    apiKey: {
      type: String,
      required: true
    },
    font: {
      type: String,
      "default": 'Roboto'
    },
    hideIcon: Boolean,
    hidePostalCode: Boolean,
    iconStyle: {
      type: String,
      "default": 'default'
    },
    zip: {
      type: String,
      "default": ''
    }
  },
  data: function data() {
    return {
      card: null,
      cardError: null,
      elements: null,
      isReady: false,
      okToSubmit: false,
      stripe: null
    };
  },
  computed: {
    classes: function classes() {
      return _objectSpread({}, _lib.VTextField.options.computed.classes.call(this), {
        'v-stripe-input': true
      });
    }
  },
  watch: {
    isDark: function isDark(newVal, oldVal) {
      if (newVal !== oldVal && this.card !== null) {
        var style = this.genStyle(this.font, this.$vuetify.theme.currentTheme, this.$vuetify.theme.dark);
        this.card.update({
          style: style
        });
      }
    },
    isDisabled: function isDisabled(disabled, oldVal) {
      if (disabled !== oldVal) {
        this.card.update({
          disabled: disabled
        });
      }
    }
  },
  mounted: function mounted() {
    var _this = this;

    // Handle tasks NOT related to actual DOM rendering or manipulation
    var cardProps = {
      classes: {
        focus: 'focus',
        empty: 'empty'
      },
      disabled: this.disabled,
      hideIcon: this.hideIcon,
      hidePostalCode: this.hidePostalCode,
      iconStyle: this.iconStyle,
      style: this.genStyle(this.font, this.$vuetify.theme.currentTheme, this.$vuetify.theme.dark),
      value: {
        postalCode: this.zip
      }
    };
    this.loadStripe() // initialize the Stripe.js object
    .then(function () {
      _this.stripe = Stripe(_this.apiKey);
    }) // eslint-disable-line no-undef
    // then create a Stripe elements generator
    .then(function () {
      return _this.stripe.elements(_this.genFont(_this.font));
    }) // then create a card element
    .then(function (elements) {
      return elements.create('card', cardProps);
    }) // then setup card events and mount the card
    .then(function (card) {
      _this.card = card;
      card.on('blur', _this.onCardBlur);
      card.on('change', _this.onCardChange);
      card.on('focus', _this.onCardFocus);
      card.on('ready', _this.onCardReady);
      card.mount("#".concat(_this.computedId));
    })["catch"](function (err) {
      console.log(err);
    });
  },
  methods: {
    clearableCallback: function clearableCallback() {
      this.card.clear();

      _lib.VTextField.options.methods.clearableCallback.call(this);
    },

    /**
     * TODO: Should this throw an error if the font is invalid?
     * Allows users of the component to specify the font that will be used
     * inside the text fields generated by Stripe. Does NOT affect the font
     * used by the label, hint, or error messages. These fonts can/should be
     * set at the app level along with all of the other UI fonts.
     *
     * @param   {string} font The name of a Google font, or a URL to a valid font
     * @returns {object}      An object in the form required by `Stripe.elements()`
     */
    genFont: function genFont(font) {
      var cssSrc = this.isURL(font) ? font : "https://fonts.googleapis.com/css?family=".concat(encodeURI(font), ":400");
      return {
        fonts: [{
          cssSrc: cssSrc
        }]
      };
    },

    /**
     * Generates the HTML element to which the Stripe element will attach
     * itself. All that is needed is a <div> with a known ID. This <div>
     * gets replaced by Stripe with an IFrame with their custom inputs.
     * see: {@link|https://stripe.com/docs/stripe-js/reference#element-mount}
     */
    genInput: function genInput() {
      return this.$createElement('div', {
        attrs: {
          id: this.computedId
        }
      });
    },

    /**
     * Maintains the ability for users of the component to control the
     * loading/progress indicator of the component, but also shows the
     * progress bar while the Stripe library is being loaded.
     */
    genProgress: function genProgress() {
      if (this.loading === false && this.isReady) return null;
      return this.$slots.progress || this.$createElement(_lib.VProgressLinear, {
        props: {
          absolute: true,
          color: this.loading === true || this.loading === '' ? this.color || 'primary' : this.loading || 'primary',
          height: this.loaderHeight,
          indeterminate: true
        }
      });
    },

    /**
     * Generate styles for Stripe elements
     */
    genStyle: function genStyle(font, theme) {
      var dark = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      return {
        base: {
          color: dark ? '#ffffff' : '#000000',
          fontFamily: "'".concat(font, "', sans-serif"),
          fontSize: '16px',
          fontSmoothing: 'antialiased',
          iconColor: dark ? '#eceff1' : '#455a64',
          '::placeholder': {
            color: dark ? 'rgb(255,255,255,0.7)' : 'rgb(0,0,0,0.54)'
          },
          ':focus::placeholder': {
            color: dark ? 'rgb(255,255,255,0.7)' : 'rgb(0,0,0,0.54)'
          }
        },
        invalid: {
          color: theme.error,
          iconColor: theme.error
        }
      };
    },

    /**
     * Loosely validates a URL
     * Based on: {@link|https://github.com/segmentio/is-url}
     *
     * @param   {string}  url The string to be tested
     * @returns {boolean}     True if the url string passes the test
     */
    isURL: function isURL(url) {
      var protocolAndDomainRegex = /^(?:\w+:)?\/\/(\S+)$/;
      var localhostDomainRegex = /^localhost[:?\d]*(?:[^:?\d]\S*)?$/;
      var nonLocalhostDomainRegex = /^[^\s.]+\.\S{2,}$/;
      if (typeof url !== 'string') return false;
      var match = url.match(protocolAndDomainRegex);
      if (!match) return false;
      var everythingAfterProtocol = match[1];
      if (!everythingAfterProtocol) return false;

      if (localhostDomainRegex.test(everythingAfterProtocol) || nonLocalhostDomainRegex.test(everythingAfterProtocol)) {
        return true;
      }

      return false;
    },
    loadStripe: function loadStripe() {
      // is Stripe already available?
      if (typeof Stripe !== 'undefined') return Promise.resolve(true); // is the external script loader available?

      if (typeof this.$loadScript === 'undefined') {
        // no
        throw new Error('[VStripeInput Error]: Stripe is not available and could not be loaded. Please make sure that you have installed and configured all of the necessary dependencies to use this component.');
      } else {
        // yes, let's try to get Stripe
        return this.$loadScript('https://js.stripe.com/v3/').then(function () {
          return true;
        })["catch"](function (err) {
          throw new Error('[VStripeInput Error] There was a problem loading Stripe: ' + err.message);
        });
      }
    },
    onCardBlur: function onCardBlur(e) {
      this.isFocused = false;
      this.$emit('blur', e);
    },
    onCardChange: function onCardChange(e) {
      if (e.error) {
        // handle card errors
        this.errorBucket.push(e.error.message);
      }

      if (e.complete) {
        // handle card input is complete
        this.errorBucket = [];
      }

      if (e.empty) {
        this.lazyValue = !e.empty;
      }
    },
    onCardFocus: function onCardFocus(e) {
      this.isFocused = true;
      this.$emit('focus', true); // Do we want to emit? Is this the right value to emit?
    },
    onCardReady: function onCardReady(e) {
      this.isReady = true;
      this.autofocus && this.card.focus();
      this.$emit('ready', e);
    },
    setLabelWidth: function setLabelWidth() {
      if (!this.outlined) return;
      this.labelWidth = this.$refs.label.offsetWidth * 0.75 + 6;
    }
  }
});

exports["default"] = _default;
//# sourceMappingURL=VStripeInput.js.map